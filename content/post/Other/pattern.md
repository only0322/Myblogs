---
title: "23种设计模式归纳"
date: 2020-06-11T22:24:14+08:00
draft: true
---


## 设计模式的定义

软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。

开闭原则：鼓励扩展，但拒绝（或不推荐）修改。比如BFF中经常出现v2,v3的函数。

## 设计模式的分类

总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。


### 一、单例模式

概念：

1. 单例类只能有一个实例。
2. 单例类必须自己创建自己的唯一实例。
3. 单例类必须给所有其他对象提供这一实例。



以Node.js代码为例：


```js
//类定义
class HttpManager {
    constructor() {
        
    }
}

exports.http = new HttpManager();

//main.js

const HttpManager = require('./HttpManager.js');
async function main() {
    let http = new HttpManager();
    global.http = http; //个人认为是关键代码
}

main();
```

优点：
1. 在内存中只有一个实例，减少内存开销，同时不需要考虑资源的多重占用。
2. 在Nodejs中，这样可以全局地调用这些类的方法，不需要导入模块了。

缺点：
1. 在Vscode中，这样实现单例类不能进行代码跳转，极其考验对系统的理解能力。
2. 没有接口，不能继承（私有），与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

**单例类设计出来，可能内部也没有资源加解锁的逻辑？所以不让别人继承？**

### 二、工厂模式

简单工厂模式属于类的创建型模式,又叫做静态工厂方法模式。通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 



实际的场景：

1. 图形化库中，单行的编辑栏和多行的编辑栏，都是继承了基类的编辑功能，只是各自进行了扩展。（**是否是工厂模式？**）

2. 设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

3. 数据库的odbc，golang和Java提送连接数据库的包。

作用：

1. 工厂模式是为了解耦：把对象的创建和使用的过程分开。就是Class A 想调用 Class B ，那么A只是调用B的方法，而至于B的实例化，就交给工厂类。

2. 工厂模式可以降低代码重复。如果创建对象B的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。我们可以这些创建对象B的代码放到工厂里统一管理。既减少了重复代码，也方便以后对B的创建过程的修改维护。

3. 因为工厂管理了对象的创建逻辑，使用者并不需要知道具体的创建过程，只管使用即可，减少了使用者因为创建逻辑导致的错误。(如对数据库的操作，mysql，oracle等。)

### 三、抽象工厂模式

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

### 四、建造者模式

建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

