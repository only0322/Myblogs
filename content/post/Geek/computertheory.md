---
title: "深入浅出计算机组成原理"
date: 2021-05-26T16:53:38+08:00
draft: true
---

## 入门

### 一、冯诺依曼体系结构

必备硬件：CPU、内存、主板、硬盘、输入输出设备，显卡。

可选硬件：独立显卡、机箱、风扇。

手机将CPU、内存、网络通信，乃至摄像头芯片，都封装到一个芯片，然后再嵌入到手机主板上。这种方式叫 SoC，也就是 System on a Chip（系统芯片）。

这样看起来，个人电脑和智能手机的硬件组成方式不太一样。可是，我们写智能手机上的 App，和写个人电脑的客户端应用似乎没有什么差别，因为，无论是个人电脑、服务器、智能手机，还是 Raspberry Pi 这样的微型卡片机，都遵循着同一个“计算机”的抽象概念。这其实就是，计算机祖师爷之一冯·诺依曼（John von Neumann）提出的冯·诺依曼体系结构（Von Neumann architecture），也叫存储程序计算机。

#### 存储程序计算机

可编程、可存储。

计算器的本质是一个不可编程的计算机。

#### 知识地图

![知识地图](/images/geek/computer/all.png)

### 二、什么是计算机的性能？

性能其实就是时间的倒数。

对于计算机的性能，我们需要有个标准来衡量。这个标准中主要有两个指标。

第一个是响应时间（Response time）或者叫执行时间（Execution time）。想要提升响应时间这个性能指标，你可以理解为让计算机“跑得更快”。

第二个是吞吐率（Throughput）或者带宽（Bandwidth），想要提升这个指标，你可以理解为让计算机“搬得更多”。

性能 = 1/ 响应时间

程序的 CPU 执行时间 =CPU 时钟周期数×时钟周期时间

CPU的主频数，就是一秒钟能执行多少条指令。这个 2.8GHz，我们可以先粗浅地认为，CPU 在 1 秒时间内，可以执行的简单指令的数量是 2.8G 条。

更准确的描述是CPU的钟表能识别出来的最小时间间隔。而在 CPU 内部，和我们平时戴的电子石英表类似，有一个叫晶体振荡器（Oscillator Crystal）的东西，简称为晶振。我们把晶振当成 CPU 内部的电子表来使用。晶振带来的每一次“滴答”，就是时钟周期时间。

超频就是将CPU内部的时钟调快了。

程序的 CPU 执行时间 =CPU 时钟周期数×时钟周期时间

**不同指令的周期数不同，加法比乘法需要的时钟周期数更少**


我们可以把自己想象成一个 CPU，坐在那里写程序。

计算机主频就好像是你的打字速度，打字越快，你自然可以多写一点程序。

CPI 相当于你在写程序的时候，熟悉各种快捷键，越是打同样的内容，需要敲击键盘的次数就越少。

指令数相当于你的程序设计得够合理，同样的程序要写的代码行数就少。

如果三者皆能实现，你自然可以很快地写出一个优秀的程序，你的“性能”从外面来看就是好的。

#### CPU的主频真的和性能直接挂钩吗？

早期工程师们想要提升CPU的性能，会盲目地提升主频，因为修改指令集和指令实现显然没有增加几个晶体管来得简单。

功耗 ~= 1/2 ×负载电容×电压的平方×开关频率×晶体管数量

那么，为了要提升性能，我们需要不断地增加晶体管数量。同样的面积下，我们想要多放一点晶体管，就要把晶体管造得小一点。这个就是平时我们所说的提升“制程”。

CPU的电压低了，散热才容易跟得上。

#### 并行优化，理解阿姆达尔定律

CPU的多核是将任务拆分成多个核心进行并行计算，但总有任务是无法并行计算的，并且最后还是需要汇总到一起的。

优化后的执行时间 = 受优化影响的执行时间 / 加速倍数 + 不受影响的执行时间

#### 提升性能

如今提升CPU核心数，或者并行运算，又或是提升主频，都会遇到瓶颈。

1. 加速运算：矩阵和向量运算用GPU来代替CPU。

2. 拆分运算：将CPU执行的过程进行拆分。

3. 通过预测提高性能。通过预先猜测下一步该干什么，而不是等上一步运行的结果，提前进行运算，也是让程序跑得更快一点的办法。

## 原理

### 一、纸带编程

通过objdump命令，可以将可执行程序反汇编成机器码。
```c
test.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 <main>:
int main()
{
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
  int a = 1; 
   4:   c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1
  int b = 2;
   b:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
  a = a + b;
  12:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
  15:   01 45 fc                add    DWORD PTR [rbp-0x4],eax
}
  18:   5d                      pop    rbp
  19:   c3                      ret    
```

    常见的指令可以分成五大类。

    第一类是算术类指令。我们的加减乘除，在 CPU 层面，都会变成一条条算术类指令。

    第二类是数据传输类指令。给变量赋值、在内存里读写数据，用的都是数据传输类指令。

    第三类是逻辑类指令。逻辑上的与或非，都是这一类指令。

    第四类是条件分支类指令。日常我们写的“if/else”，其实都是条件分支类指令。

    最后一类是无条件跳转指令。写一些大一点的程序，我们常常需要写一些函数或者方法。在调用函数的时候，其实就是发起了一个无条件跳转指令。

除了 C 这样的编译型的语言之外，不管是 Python 这样的解释型语言，还是 Java 这样使用虚拟机的语言，其实最终都是由不同形式的程序，把我们写好的代码，转换成 CPU 能够理解的机器码来执行的。

只是解释型语言，是通过解释器在程序运行的时候逐句翻译，而 Java 这样使用虚拟机的语言，则是由虚拟机对编译出来的中间代码进行解释，或者即时编译成为机器码来最终执行。

