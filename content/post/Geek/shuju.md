---
title: "数据结构与算法之美学习笔记"
date: 2020-10-17T23:00:04+08:00
draft: true
---

## 一、入门

### 常见的时间复杂度类型

#### 1.O(1)

```cpp

 int i = 8;
 int j = 6;
 int sum = i + j;
 ```

 代码的运行次数不会随着n进行变化，比如没有进入循环，所以是O(1)级别

 #### 2.O(logn)、O(nlogn)

```cpp
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
 ```

 比如以下这段代码，就是O(log3n)。

 ```cpp

 i=1;
 while (i <= n)  {
   i = i * 3;
 }
 ```

 我们知道，对数之间是可以互相转换的，log3n 就等于 log32 * log2n，所以 O(log3n) = O(C * log2n)，其中 C=log32 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。所以，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。

 #### 3.O(m+n)、O(m*n)

 ```cpp

int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。

所以，上面代码的时间复杂度就是 O(m+n)。针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。


### 常见的空间复杂度类型

```cpp

void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}

```

跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。
第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。



## 二、基础

### 1.基于链表的LRU缓存淘汰算法

LRU：最近最少使用

我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。

当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。

2. 如果此数据没有在缓存链表中，又可以分为两种情况：如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

这样就实现了一个LRU算法。

### 2.栈在括号匹配中的作用 

当遇到左括号的时候，压入栈，遇到右括号的时候出栈。空栈遇到右括号的话，则表示这个括号对已经不匹配了。

只要最后看栈中的元素是否为空，就能知道括号是否匹配了。

栈也可以实现浏览器的前进后退，前进的时候在后退栈压入数据（同时可能需要出栈），后退的时候出栈，入前进栈。前进时前进栈出栈，入后退栈。

### 3.队列的用途 阻塞队列

简单来说就是资源比较紧张的时候，会判断队列内是否存放了东西，如果队列为空的话，会一直阻塞到队列内有值才放行。但这样实现的话效率会低一点。

### 4.递归的简单理解

其实就是去电影院问座位号，坐在中间的人自己也不知道，需要传递到第一排问到结果，再传回来，递和归的过程。

### 5.为什么Redis用的是跳表而不是红黑树呢？

 
![跳表](/images/geek/shuju/jump.png)


如果我们现在要查找某个结点，比如 16。我们可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，我们发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。

然后我们通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时候，我们只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。


**简而言之**

跳表和时间复杂度几乎和红黑树一样，而且实现起来简单。

### 6.检查拼写错误，用什么数据结构实现？

常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。

也就是哈希表，通过这个输入的单词的哈希值，在哈希表中寻找是否有匹配的值，若没有则说明是一个错误的拼写。


哈希表解决冲突，暂时掌握拉链法。

### 7.哈希算法对数据分片和负载均衡的处理。

比如ip地址相同的请求，通过计算哈希值取模，一定可以分配到同一台服务器进行处理。

对于关键词的次数统计等问题，可以通过哈希值计算后，分配给每个计算机进行处理，而不是堆给一台服务器。

分布式系统，也许会大量使用哈希算法来进行负载方面的处理。

