---
title: "JavaScript核心原理解析"
date: 2021-03-29T17:57:06+08:00
draft: true
---

## 一、JavaScript语言是如何构建起来的

### 1.delete 0：JavaScript到底有什么是可以销毁的

在 JavaScript 中表达式是一个很独特的东西，所有一切表达式运算的终极目的都是为了得到一个值，例如字符串。然后再用另外一些操作将这个值输出出来，例如变成网页中的一个元素（element）。

**这个结果，才是delete这个操作要删除的东西。**

在JS中，语句和表达式可以被执行并存在执行结果。

#### delete的运算结果

1. 如果x根本不存在，delete x什么也不做，返回true

2. 删除字面量 返回true

3. 如果x是对象，delete x即删除对象本身，返回false

4. delete undefined 返回false

### 2.var x = y = 100：声明语句与语法改变了JavaScript语言核心性质

let x所声明的那个x其实也已经存在 f() 函数的上下文环境中。访问它之所以会抛出异常（Exception），不是因为它不存在，而是因为这个标识符被拒绝访问了。

JavaScript 是允许访问还没有绑定值的var所声明的标识符的。这种标识符后来统一约定称为“变量声明（varDelcs）”，而“let/const”则称为“词法声明（lexicalDecls）”。JavaScript 环境在创建一个“变量名（varName in varDecls）”后，会为它初始化绑定一个 undefined 值，而”词法名字（lexicalNames）”在创建之后就没有这项待遇，所以它们在缺省情况下就是“还没有绑定值”的标识符。

```js
a;
var a;
//undefined

b;
let b;
//Uncaught ReferenceError: Cannot access 'b' before initialization
```

JavaScript的赋值其实是将右操作数的值赋值给左操作数的引用。

也就是说，在 JavaScript 中，一个赋值表达式的左边和右边其实“都是”表达式。

变量泄漏：变量可以随用随声明，也不用像后来的let语句一样，还要考虑在声明语句之前能不能访问的问题了。但是代码多了就容易出现很多问题。

**var x = y = 100，在这行代码中，等号的右边是一个表达式y = 100，它发生了一次“向不存在的变量赋值”，所以它隐式地声明了一个全局变量y，并赋值为 100。**

```js
function main() {
    let a = b = 0;
}
main();
console.log(b); //0
console.log(a); //ReferenceError: a is not defined
```

赋值表达式也是有结果的，它的结果是右操作数的值。

### 3.a.x = a = {n:2}：一道被无数人无数次地解释过的经典面试题

（赋值表达式左侧的）操作数可以是另一个表达式——这在专栏的第一讲里就讲过了，而“var 声明”语句中的等号左边，绝不可能是一个表达式

**JavaScript 总是严格按照从左至右的顺序来计算表达式。**

例如，在表达式w = x + y * z中，将首先计算子表达式 w，然后计算 x、y 和 z；然后，y 的值和 z 的值相乘，再加上 x 的值；最后将其赋值给表达式 w 所指代的变量或属性。

但是带有var let const的变量就不是表达式而是一个标识符了。

### 4.export default function() {}：你无法导出一个匿名函数表达式

顺便说下JavaScript的模块技术，以下是导出的方式：

```js

// 导出“（声明的）名字”
export <let/const/var> x ...;
export function x() ...
export class x ...
export {x, y, z, ...};


// 导出“（重命名的）名字”
export { x as y, ...};
export { x as default, ... };


// 导出“（其它模块的）名字”
export ... from ...;


// 导出“值”
export default <expression
```

但是对于最后这种形式，也就是“（导出）值”的形式，事实上是非常特殊的。

因为如要导出一个模块的全部内容就必须导出“（全部的）名字和值”，然而纯粹的值没有名字，于是也就没法访问了，所以这就与“导出点什么东西”的概念矛盾了。

所以 ECMAScript 6 模块约定了一个称为"default"的名字，用于来导出当前模块中的一个“值”。

```js

var varName = 100;
export default {
  varName,  // 直接导出名字
  propName: 123,  // 导出值
  funcName: function() { }, // 导出函数
  foo() { // 或导出与主对象相关联的方法
     // method
  }
}
```

export做了下面两件事：导出一个名字，为上述名字绑定一个值

和用let声明一个变量的过程是一致的。

import则做如下工作：按照语法在当前模块声明名字，添加一个当前模块对目标模块的依赖项。

有了上述的第二步操作，JavaScript 就可以依据所有它能在静态文本中发现的import语句来形成模块依赖树，最后就可以找到这个模块依赖树最顶端的根模块，并尝试加载之。

**在处理 export/import 语句的全程，没有表达式被执行**

按照 JavaScript 的约定，匿名函数表达式可以理解为一个函数的“字面量（值）;

```js
let a = function b () {

}

a();
b();//此时会报错 b is not defined
```

export ...语句通常是按它的词法声明来创建的标识符的，例如export var x = ...就意味着在当前模块环境中创建的是一个变量，并可以修改等等。但是当它被导入时，在import语句所在的模块中却是一个常量，因此总是不可写的。

由于export default ...没有显式地约定名字“default（或default）”应该按let/const/var的哪一种来创建，因此 JavaScript 缺省将它创建成一个普通的变量（var），但即使是在当前模块环境中，它事实上也是不可写的，因为你无法访问一个命名为“default”的变量——它不是一个合法的标识符。

### 4.for循环并不比使用函数递归节省开销

块级作用域：大括号划分的一个区域

switch语句只有一个作用域。

```js
var x = 1, c = 'a';
switch (c) {
    case 'a':
        console.log(x); // ReferenceError
        break;
    case 'b':
        let x = 200;
        break;
}
```

**主要是let又重新申明了**

在这个例子中，switch 语句内是无法访问到外部变量x的，即便声明变量x的分支case 'b'永远都执行不到。这是因为所有分支都处在同一个块级作用域中，所以任意分支的声明都会给该作用域添加这个标识符，从而覆盖了全局的变量x。

还有try catch finally with

由于函数存在“重新进入”的问题，所以它必须有一个作用域来管理“重新进入之前”的那些标识符。这个东西想必你是听说过的，它被称为“闭包”。

`for(var x = ...)`就是变量提升，越过当前语法范围，在更外围的作用域登记名字。

在循环体内是否需要一个新的块级作用域呢？这取决于在语言设计上是否支持如下代码：

```js
for (let x = 102; x < 105; x++)
  let x = 200;
```

JavaScript是不允许申明新的变量的，但这却是一个普遍存在的语法禁例。

```js

// if语句中的禁例
if (false) let x = 100;

// while语句中的禁例
while (false) let x = 200;

// with语句中的禁例
with (0) let x = 300
```

所以，现在可以确定：循环语句（对于支持“let/const”的 for 语句来说）“通常情况下”只支持一个块级作用域。

更进一步地说，在上面的代码中，我们并没有机会覆盖 for 语句中的“let/const”声明。

但`for(let i=0;...)`这样的代码显然必须增加作用域了。

在语法设计上，需要为使用let/const声明循环变量的 for 语句多添加一个作用域。

在 JavaScript 的具体执行过程中，作用域是被作为环境的上下文来创建的。如果将 for 语句的块级作用域称为 forEnv，并将上述为循环体增加的作用域称为 loopEnv，那么 loopEnv 它的外部环境就指向 forEnv。于是在 loopEnv 看来，变量i其实是登记在父级作用域 forEnv 中，并且 loopEnv 只能使用它作为名字“i”的一个引用。

更准确地说，在 loopEnv 中访问变量i，在本质上就是通过环境链回溯来查找标识符（Resolve identifier, or Get Identifier Reference）。

```js

for (let i in x)
  setTimeout(()=>console.log(i), 1000);
```

这样的代码显然需要创建无数个副本才能使运行结果符合预期。

一种理论上的观点，也就是所谓“循环与函数递归在语义上等价”。所以在事实上，上述这种 for 循环并不比使用函数递归节省开销。

## 二、从表达式到引擎：JavaScript是如何运行的

### 1.break语句

已经废弃goto操作，因为太古老且难以维护。


>作用域退出，就是函数 RETURN。
>作用域挂起，就是执行权的转移。
>作用域的创建，就是一个闭包的初始化。

### 2.JavaScript中特殊的可执行结构

在 JavaScript 语言的内核中，参数表其实是一个独立的语法组件：
- 对于函数来说，参数表就是在函数调用时传入的参数 0 到 n；

- 对于构造器以及构造器的 new 运算来说，参数表就是 new 运算的一个运算数。

参数列表就是一个模板。

所有这些执行的结果都是一个名字，执行的语义就是给这个名字一个值。显然这是不够的，因为除了给这个名字一个值之外，最终还得使用这个名字以便进行更多的运算。

那么，这个“找到名字并使用名字”的过程，就称为“发现（Resolve binding）”，而其结果，就称为“引用（reference）”

**发现一个名字与发现一个值本质上没有什么不同**

```js
a = 1
1 = 1
```

### 3.x => x：函数式语言的核心抽象：函数与表达式的同一性

讲述函数的执行过程：

**函数的一体两面**

用静态的视角来看函数，它就是一个函数对象（函数的实例）。如果不考虑它作为对象的那些特性，那么函数也无非就是“用三个语义组件构成的实体”。

这三个语义组件是指：

1. 参数：函数总是有参数的，即使它的形式参数表为空；

2. 执行体：函数总是有它的执行过程，即使是空的函数体或空语句；

3. 结果：函数总是有它的执行的结果，即使是 undefined。

```js
function f() {
  ...
}
```

语法( )指示了参数，而{ }指示了执行体，并且，我们隐式地知道该函数有一个结果。这也是 JavaScript 设计经常被批判的一处：由于没有静态类型声明，所以我们也无法知道函数返回何种结果。

```js

var arr = new Array;
for (var i=0; i<5; i++) arr.push(function f() {
  // ...
});
```

任何时候只要用户代码引用一次这样的函数（的声明或字面量），那么它就会拿到该函数的一个闭包。注意，得到这个闭包的过程与是否调用它是无关的。

