---
title: "Node.js后端面试整理"
date: 2022-03-07T11:06:57+08:00
draft: true
---

# 一、Node.js语言部分

## I.语言基础

### 1.闭包的原理

函数就是一个闭包，js的特点是可以在函数内部创建另一个函数。js可以在函数内用外部的变量，所以自然而然产生的闭包概念。

```js
function foo(){
  var local = 1
  function bar(){
    local++
    return local
  }
  return bar
}

var func = foo()
func()
```

在内部的那个函数可以引用外部的变量，但同时这个变量也无法被销毁，有消耗内存的风险。


#### 块级作用域 

{}也是划分作用域的概念，和闭包略有不同。

### 2.Js的内置对象

Object、Array、Boolean、Number、String、Buffer等等。

### 3.Nodejs gc



#### 引用计数法

假设有一个对象A，任何对象对A进行引用，那么对象A的引用计数器+1，当引用失效时，对象A的引用计数器-1，当对象A的引用计数器为0时，就说明对象A没用被引用，那么就可以进行回收。

##### 优点：
- 实时性高 不需要等内存不足再回首。

- 垃圾回收的时候不需要挂起应用。

- 区域更新对象，不需要扫描全部对象

##### 缺点：
- 每次对象被引用都要更新

- 浪费cpu资源，因为内存足够的时候还在统计

- 无法解决循环引用

比如两个对象互相引用 都赋值成null，那就永远回收不了了。

#### 标记清除法

标记清除法是把gc分为两个阶段，标记和清除。

- 标记：从根节点开始标记引用的对象

- 清除：没被标记的就是垃圾对象 可以清除。

结构有点像多叉树。

从根节点开始遍历，找到所有可达的对象，其他的都是可以清除的。

##### 优点

解决了循环引用的问题

##### 缺点

标记和清除都需要遍历所有对象，gc的时候需要暂停程序。对交互性高的程序体验很差。

内存碎片多，被清理的对象在内存的各个角落。

#### 标记压缩算法

标记压缩算法是在标记清除法的基础上进行了优化，标记阶段是一样的，在清理阶段不是直接清理标记对象，而是将存活对象压缩到内存的一端，然后清理边界以外的垃圾，从而解决碎片化问题。


##### 优缺点

解决了内存碎片化的问题，但是多了压缩的一步，对象移动内存位置的步骤，对效率有影响。

### 4. 原型

在js中，对象都有__proto__属性，一般这个是被称为隐式的原型，该隐式原型指向构造该对象的构造函数的原型。

函数比较特殊，它除了和其他对象一样有__proto__属性，还有自己特有的属性----prototype，这个属性是一个指针，指向一个包含所有实例共享的属性和方法的对象，称之为原型对象。原型对象也有一个constructor属性，该属性指回该函数。



## II.libuv原理

libuv底层是用了生产者-消费者的模型，libuv在整个生命周期中，每一次循环都执行每个阶段（phase）维护的任务队列。逐个执行节点里的回调，在回调中，不断生产新的任务，从而不断驱动libuv。

### Nodejs的事件循环原理

事件循环底层使用libuv。
#### Nodejs的特点

单线程，它不会为每个请求分配一个线程，而是用主线程处理所有请求，对输入输出进行异步处理，避开了创建销毁线程，和线程切换的开销和复杂性。

#### 核心原理

Node.js 在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。

当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 I/O 任务，就从 线程池 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。

当线程中的 I/O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 事件循环 (Event Loop)。

无论是 Linux 平台还是 Windows 平台，Node.js 内部都是通过 线程池 来完成异步 I/O 操作的，而 LIBUV 针对不同平台的差异性实现了统一调用。因此，Node.js 的单线程仅仅是指 JavaScript 运行在单线程中，而并非 Node.js 是单线程。

在事件队列中，如果前面的 CPU 计算任务没有完成，后面的任务就会被阻塞，出现响应缓慢的情况，当 Node.js 被CPU 密集型任务占用，导致其他任务被阻塞时，却还有 CPU 内核处于闲置状态，造成资源浪费。

#### 使用要点

尽量不在服务器中使用需要同步等待的CPU密集型任务，如fs的同步读文件，因为这会阻塞事件队列的轮询。

**每个 CPU 密集任务只在它被调度到的时候才会得到执行。**

Node.js 有两种类型的线程：一个事件循环线程和 k 个工作线程。 事件循环负责 JavaScript 回调和非阻塞 I/O，工作线程执行与 C++ 代码对应的、完成异步请求的任务，包括阻塞 I/O 和 CPU 密集型工作。 

这两种类型的线程一次都只能处理一个活动。 如果任意一个回调或任务需要很长时间，则运行它的线程将被 阻塞。 如果你的应用程序发起阻塞的回调或任务，在好的情况下这可能只会导致吞吐量下降（客户端/秒），而在最坏情况下可能会导致完全拒绝服务。

## III.v8

v8解决的问题是快速解析和执行JavaScript脚本。

### 1.内存限制

32位是0.7gb，64位是1.4gb

### 2.和Nodejs的关系

v8把js代码翻译成机器码，直接运行。

### 3.内存结构

内存区主要能够分为如下几类：栈区、堆区、常量区、函数定义区、函数缓存区。

#### 堆区

JavaScript的变量名是用来保存内存中某块内存区的地址的，而栈区就是用来保存变量名和内存地址的键值对的。

```js
let a = {}
```

对于该语句，V8会在堆区中开辟一块内存，而后在栈区添加一个键值对，键名是咱们声明的变量名a，键值是堆区中开辟出的内存的地址。

在堆区中存在一个特殊的预置对象null，它在堆区中有固定的内存地址，而且是惟一的。也就是说全部被赋值为null的变量指向的都是这同一块内存地址（所以被赋值为null的变量也是有内存地址的）。

#### 常量区


- 全部的值都是不可变的
- 全部相同的常量值在常量区都是唯一的。

#### 函数定义区

```js
//函数声明
function f(){
  ...
}
//函数引用
var f = function(){
 ...
}
```

其实没什么卵用的知识。

```js
//能够正常调用，由于引擎会提早扫描代码，将该函数存储到函数定义区
f();
function f(){}

//报错，由于虽然g也进行了变量提高，但此时g的值是undefined，不能调用
g();
var g = function(){}
```
#### 函数缓存区

所谓函数缓存区，就是函数运行所用的内存区。当V8引擎须要执行一个函数时，它就会在函数缓存区开辟一块内存，保存该函数运行所须要存储的状态和变量。

一般情况都会回收内存，用了闭包就有可能不回收（上面有提到）

#### 理解 == 和 ===

```js
var a = 1;
var b = 1;
a === b;   //值为true，同一个常量在常量区只会生成一个，所以二者获得地址是同样的

var a = {};
var b = {};
a === b;    //值为false，引擎会分别为a和b开辟内存，所以二者的地址并不相同

null === null;  //值为true，由于堆区只有一个null
[] === [];  //值为false，原理与{}相同
```

在比较字符串的时候，数字会先转成字符串，然后去比较地址。


### 4.V8的垃圾回收机制

V8的垃圾回收机制采用的是标记清除法，这也是如今JavaScript引擎通用的一种回收机制。

新生代空间小一点，老生代空间大一点。

#### 新生代

新生代区域一分为二，每个16M，一个使用，一个空闲。

开始垃圾回收的时候，会检查FROM区域中的存活对象，如果还活着，拷贝到TO空间，所有存活对象拷贝完后，清空(释放)FROM区域
然后FROM和To区域互换。

新生代的空间小，存活对象少。

当一个对象经理多次的垃圾回收依然存活的时候，生存周期比较差的对象会被移动到老生代，这个移动过程被称为晋升或升级。

- 经历过5次以上的回收还存在

- TO的空间使用占比超过25%，或者超大对象

#### 老生代

老生代垃圾回收策略分为两种：

##### mark-sweep 标记清除

标记活着的对象，虽然清楚在标记阶段没有标记的对象，只清理死亡对象

会出现的问题：清除后内存不连续，碎片内存无法分配

##### mark-compact 标记整理

标记死亡后会对对象进行整理，活着的左移，移动完成后清理掉边界外的内存(死亡的对象)

老生代空间大，大部分都是活着的对象，GC耗时比较长

**GC的时候程序无法进行响应**

# 二、计算机网络

# 三、数据结构和算法

# 四、数据库

# 五、设计模式

# 六、Linux

# 七、容器云

# 八、Redis

# 九、操作系统