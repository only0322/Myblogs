---
title: "Node.js后端面试整理"
date: 2022-03-07T11:06:57+08:00
draft: true
---

# 一、Node.js语言部分

## I.语言基础

### 1.闭包的原理

函数就是一个闭包，js的特点是可以在函数内部创建另一个函数。js可以在函数内用外部的变量，所以自然而然产生的闭包概念。

```js
function foo(){
  var local = 1
  function bar(){
    local++
    return local
  }
  return bar
}

var func = foo()
func()
```

在内部的那个函数可以引用外部的变量，但同时这个变量也无法被销毁，有消耗内存的风险。


#### 块级作用域 

{}也是划分作用域的概念，和闭包略有不同。

### 2.Js的内置对象

Object、Array、Boolean、Number、String、Buffer等等。

### 3.Nodejs gc



#### 引用计数法

假设有一个对象A，任何对象对A进行引用，那么对象A的引用计数器+1，当引用失效时，对象A的引用计数器-1，当对象A的引用计数器为0时，就说明对象A没用被引用，那么就可以进行回收。

##### 优点：
- 实时性高 不需要等内存不足再回首。

- 垃圾回收的时候不需要挂起应用。

- 区域更新对象，不需要扫描全部对象

##### 缺点：
- 每次对象被引用都要更新

- 浪费cpu资源，因为内存足够的时候还在统计

- 无法解决循环引用

比如两个对象互相引用 都赋值成null，那就永远回收不了了。

#### 标记清除法

标记清除法是把gc分为两个阶段，标记和清除。

- 标记：从根节点开始标记引用的对象

- 清除：没被标记的就是垃圾对象 可以清除。

结构有点像多叉树。

从根节点开始遍历，找到所有可达的对象，其他的都是可以清除的。

##### 优点

解决了循环引用的问题

##### 缺点

标记和清除都需要遍历所有对象，gc的时候需要暂停程序。对交互性高的程序体验很差。

内存碎片多，被清理的对象在内存的各个角落。

#### 标记压缩算法

标记压缩算法是在标记清除法的基础上进行了优化，标记阶段是一样的，在清理阶段不是直接清理标记对象，而是将存活对象压缩到内存的一端，然后清理边界以外的垃圾，从而解决碎片化问题。


##### 优缺点

解决了内存碎片化的问题，但是多了压缩的一步，对象移动内存位置的步骤，对效率有影响。

### 4. 原型

在js中，对象都有__proto__属性，一般这个是被称为隐式的原型，该隐式原型指向构造该对象的构造函数的原型。

函数比较特殊，它除了和其他对象一样有__proto__属性，还有自己特有的属性----prototype，这个属性是一个指针，指向一个包含所有实例共享的属性和方法的对象，称之为原型对象。原型对象也有一个constructor属性，该属性指回该函数。



## II.libuv原理

libuv底层是用了生产者-消费者的模型，libuv在整个生命周期中，每一次循环都执行每个阶段（phase）维护的任务队列。逐个执行节点里的回调，在回调中，不断生产新的任务，从而不断驱动libuv。

### Nodejs的事件循环原理

事件循环底层使用libuv。
#### Nodejs的特点

单线程，它不会为每个请求分配一个线程，而是用主线程处理所有请求，对输入输出进行异步处理，避开了创建销毁线程，和线程切换的开销和复杂性。

#### 核心原理

Node.js 在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。

当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 I/O 任务，就从 线程池 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。

当线程中的 I/O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 事件循环 (Event Loop)。

无论是 Linux 平台还是 Windows 平台，Node.js 内部都是通过 线程池 来完成异步 I/O 操作的，而 LIBUV 针对不同平台的差异性实现了统一调用。因此，Node.js 的单线程仅仅是指 JavaScript 运行在单线程中，而并非 Node.js 是单线程。

在事件队列中，如果前面的 CPU 计算任务没有完成，后面的任务就会被阻塞，出现响应缓慢的情况，当 Node.js 被CPU 密集型任务占用，导致其他任务被阻塞时，却还有 CPU 内核处于闲置状态，造成资源浪费。

#### 使用要点

尽量不在服务器中使用需要同步等待的CPU密集型任务，如fs的同步读文件，因为这会阻塞事件队列的轮询。

**每个 CPU 密集任务只在它被调度到的时候才会得到执行。**

Node.js 有两种类型的线程：一个事件循环线程和 k 个工作线程。 事件循环负责 JavaScript 回调和非阻塞 I/O，工作线程执行与 C++ 代码对应的、完成异步请求的任务，包括阻塞 I/O 和 CPU 密集型工作。 

这两种类型的线程一次都只能处理一个活动。 如果任意一个回调或任务需要很长时间，则运行它的线程将被 阻塞。 如果你的应用程序发起阻塞的回调或任务，在好的情况下这可能只会导致吞吐量下降（客户端/秒），而在最坏情况下可能会导致完全拒绝服务。

## III.v8

v8解决的问题是快速解析和执行JavaScript脚本。

### 1.内存限制

32位是0.7gb，64位是1.4gb

### 2.和Nodejs的关系

v8把js代码翻译成机器码，直接运行。

### 3.内存结构

内存区主要能够分为如下几类：栈区、堆区、常量区、函数定义区、函数缓存区。

#### 堆区

JavaScript的变量名是用来保存内存中某块内存区的地址的，而栈区就是用来保存变量名和内存地址的键值对的。

```js
let a = {}
```

对于该语句，V8会在堆区中开辟一块内存，而后在栈区添加一个键值对，键名是咱们声明的变量名a，键值是堆区中开辟出的内存的地址。

在堆区中存在一个特殊的预置对象null，它在堆区中有固定的内存地址，而且是惟一的。也就是说全部被赋值为null的变量指向的都是这同一块内存地址（所以被赋值为null的变量也是有内存地址的）。

#### 常量区


- 全部的值都是不可变的
- 全部相同的常量值在常量区都是唯一的。

#### 函数定义区

```js
//函数声明
function f(){
  ...
}
//函数引用
var f = function(){
 ...
}
```

其实没什么卵用的知识。

```js
//能够正常调用，由于引擎会提早扫描代码，将该函数存储到函数定义区
f();
function f(){}

//报错，由于虽然g也进行了变量提高，但此时g的值是undefined，不能调用
g();
var g = function(){}
```
#### 函数缓存区

所谓函数缓存区，就是函数运行所用的内存区。当V8引擎须要执行一个函数时，它就会在函数缓存区开辟一块内存，保存该函数运行所须要存储的状态和变量。

一般情况都会回收内存，用了闭包就有可能不回收（上面有提到）

#### 理解 == 和 ===

```js
var a = 1;
var b = 1;
a === b;   //值为true，同一个常量在常量区只会生成一个，所以二者获得地址是同样的

var a = {};
var b = {};
a === b;    //值为false，引擎会分别为a和b开辟内存，所以二者的地址并不相同

null === null;  //值为true，由于堆区只有一个null
[] === [];  //值为false，原理与{}相同
```

在比较字符串的时候，数字会先转成字符串，然后去比较地址。


### 4.V8的垃圾回收机制

V8的垃圾回收机制采用的是标记清除法，这也是如今JavaScript引擎通用的一种回收机制。

新生代空间小一点，老生代空间大一点。

#### 新生代

新生代区域一分为二，每个16M，一个使用，一个空闲。

开始垃圾回收的时候，会检查FROM区域中的存活对象，如果还活着，拷贝到TO空间，所有存活对象拷贝完后，清空(释放)FROM区域
然后FROM和To区域互换。

新生代的空间小，存活对象少。

当一个对象经理多次的垃圾回收依然存活的时候，生存周期比较差的对象会被移动到老生代，这个移动过程被称为晋升或升级。

- 经历过5次以上的回收还存在

- TO的空间使用占比超过25%，或者超大对象

#### 老生代

老生代垃圾回收策略分为两种：

##### mark-sweep 标记清除

标记活着的对象，虽然清楚在标记阶段没有标记的对象，只清理死亡对象

会出现的问题：清除后内存不连续，碎片内存无法分配

##### mark-compact 标记整理

标记死亡后会对对象进行整理，活着的左移，移动完成后清理掉边界外的内存(死亡的对象)

老生代空间大，大部分都是活着的对象，GC耗时比较长

**GC的时候程序无法进行响应**

# 二、计算机网络

### I.网络架构

七层网络模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。

### II.三次握手

#### 粗略的目的

- 第一次客户端给服务器发送，服务器能确认客户端的发送、服务器的接收能力。

- 第二次服务器给客户端发送，客户端能确认服务器的发送、客户端的接收能力。同时根据第一次握手，能知道自己的发送、服务器的接收都正常。

**为什么需要三次握手**

- 因为服务器不知道自己的发送，客户端的接收是否正常，所以需要第三次握手，得到客户端的应答才能做最后的确认。

#### SYN和ACK

SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。

#### 位码

位码即tcp标志位，有6种标示：SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码)

### III.四次挥手


- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送

- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号

- 服务器-关闭与客户端的连接，发送一个FIN给客户端

- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1

### IV.各种协议

#### 1.TCP,UDP 协议的区别

UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等。

TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。

#### 2.TCP 协议如何保证可靠传输

简单来说，数据会分包、TCP有检验和：判断数据有缺失会直接丢掉，而且不确认这次收到了、流量控制、拥塞处理、ARQ协议。

#### 3.DNS

域名系统，能够获取域名对应的ip地址。

### V.http协议

#### 1.当输入www.google.com时，页面发生了哪些事情

1. 域名解析检查顺序为：浏览器自身DNS缓存---》OS自身的DNS缓存--》读取host文件--》本地域名服务器--》权限域名服务器--》根域名服务器。如果有且没有过期，则结束本次域名解析。域名解析成功之后，进行后续操作。

2. 三次握手

3. 建立连接，发起http请求。

4. 服务器响应，浏览器得到内容。

5. 浏览器解析html代码，并且请求其中的资源

6. 浏览器对页面渲染，呈现给用户。

#### 2.什么是Http协议无状态协议？怎么解决Http协议无状态协议？

http是无状态的，也就是后续处理无法处理之前的信息。

处理办法有Cookie，Section会话保存，甚至可以用数据库和缓存处理。

#### 3.http协议组成

**请求报文包含三部分：**

- 请求行：包含请求方法、URI、HTTP版本信息

- 请求首部字段

- 请求内容实体
  
**响应报文包含三部分：**

- 状态行：包含HTTP版本、状态码、状态码的原因短语

- 响应首部字段

- 响应内容实体

**空行**

最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。

**请求正文**

请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。


**返回值**


在接收和解释请求消息后，服务器返回一个HTTP响应消息。

HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文



##### 请求行

请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。

GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，

POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。

个人不推荐用GET，全部用POST比较方便。

##### 请求头部

请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：

- User-Agent：产生请求的浏览器类型。

 
- Accept：客户端可识别的内容类型列表。

 
- Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。




#### 4.状态码

- 1xx：指示信息--表示请求已接收，继续处理

- 2xx：成功--表示请求已被成功接收、理解、接受

- 3xx：重定向--要完成请求必须进行更进一步的操作

- 4xx：客户端错误--请求有语法错误或请求无法实现

- 5xx：服务器端错误--服务器未能实现合法的请求


#### 5.http的版本 1.0与1.1

在http1.0中，当建立连接后，客户端发送一个请求，服务器端返回一个信息后就关闭连接，当浏览器下次请求的时候又要建立连接，显然这种不断建立连接的方式，会造成很多问题。

在http1.1中，引入了持续连接的概念，通过这种连接，浏览器可以建立一个连接之后，发送请求并得到返回信息，然后继续发送请求再次等到返回信息，也就是说客户端可以连续发送多个请求，而不用等待每一个响应的到来。



#### 6.GET和POST的区别

GET重点是请求数据，POST的重点是提交数据。GET传输数据以URL的方式，POST通过http的post机制，把数据封装在了请求实体中，所以是不可见的，安全性也更高一点。

GET只支持ASCII字符，有可能出现乱码，POST不会。

### VI.https和http

HTTPS协议 = HTTP协议 + SSL/TLS协议，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输，由此可以看出HTTPS是由HTTP和SSL/TLS一起合作完成的。

#### 传输的过程

服务器端的公钥和私钥，用来进行非对称加密。

客户端生成的随机密钥，用来进行对称加密。

Https先用非对称加密，去加密对称加密的密钥，后面的传输都用对称加密算法，因为可以提升性能。

#### 传输步骤

一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。

- 1.客户端向服务器发起HTTPS请求，连接到服务器的443端口

- 2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。

- 3.服务器将自己的公钥发送给客户端。

- 4.客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。

- 5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。

- 6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。

- 7.然后服务器将加密后的密文发送给客户端。

- 8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。



# 三、数据结构和算法

#### 排序算法的稳定性是什么，有什么用？

稳定性，指两个相同元素在排序后的相对顺序。

稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。


## I.常见排序算法

时间复杂度中，^符号代表幂次方。

### 1.冒泡排序

冒泡排序是两层循环，将数组两个元素挨个比较，进行交换。

第一层循环是n，第二层则是n-1，所以时间复杂度为O(n^2)

稳定，因为相同的元素选择不交换即可。

### 2.选择排序

每次都寻找最大的元素，交换的相应的位置。

和冒泡排序时间复杂度一样，因为循环结构相似，O(n^2)。

不稳定，一般会颠倒位置。

### 3.插入排序

未排序的元素从已排序的元素中选择位置插入。


和冒泡排序时间复杂度一样，因为循环结构相似，O(n^2)。

稳定，后来的碰到相同元素就往后插入。



### 4.希尔排序

希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。


```c++
private static void sort(int[] array) {
        int n = array.length;
        int h = 1;
        while (h<n/3) { //动态定义间隔序列
              h = 3*h +1;
                 }
         while (h >= 1) {
            for (int i = h; i < n; i++) {
                for (int j = i; j >= h && (array[j] < array[j - h]); j -= h) {
                    int temp = array[j];
                    array[j] = array[j - h];
                    array[j-h]= temp;
                }
            }
            h /=3;
        }
    }
```
两次循环，有除以3的操作，所以是O(n^1.3)

不稳定，因为数据被打乱了。



### 5.快速排序

分治法，选中一个元素，把大的和小的各放一边，然后对每一块数据都按此方法做处理。

一次循环决定要处理几次，另外一个是递归操作，所以是O(n*logn)

递归，显然不稳定。

### 6.归并排序

将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。它使用了递归分治的思想；相当于：左半边用尽，则取右半边元素；右半边用尽，则取左半边元素；右半边的当前元素小于左半边的当前元素，则取右半边元素；右半边的当前元素大于左半边的当前元素，则取左半边的元素。

和快排的时间复杂度一样，因为都用了递归，O(n*logn)

稳定，合并序列的时候相同的往后排。

### 7.堆排序

堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

因为是二叉树，也用到了递归的概念，和快速排序类似，O(n*logn)

不稳定，构建了二叉树。

### 8.计数排序

找出待排序元素最大最小值，然后开辟数据存储，计算每个元素出现的次数，最后一次排序完毕。

时间复杂度O(n+k)

K很大的时候就不能忽略了，这是O(n+k)的含义。

稳定，倒着输出，搞一个数组的栈即可。看实现方式，如果是只记录出现的次数，最后自己组数组，则不稳定，但如果是看到有存在的元素，将元素取出来，那就是稳定的。

### 9.桶排序

将数据分到不同的桶里面排序，然后每个再分别排序。

时间复杂度O(n+k)

不稳定，不同的桶遇到相同的值不好处理。

### 10.基数排序

按每一位进行排序，先从低位开始排序，每一轮遍历，最后排序到最后一位。

时间复杂度O(n+k) 时间复杂度和位数有关系。

稳定。
 



## II.常见数据结构应用

### 1.链表LRU缓存淘汰

我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。

当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。

2. 如果此数据没有在缓存链表中，又可以分为两种情况：如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

这样就实现了一个LRU算法。

### 2.栈在括号匹配中的作用 


当遇到左括号的时候，压入栈，遇到右括号的时候出栈。空栈遇到右括号的话，则表示这个括号对已经不匹配了。

只要最后看栈中的元素是否为空，就能知道括号是否匹配了。

栈也可以实现浏览器的前进后退，前进的时候在后退栈压入数据（同时可能需要出栈），后退的时候出栈，入前进栈。前进时前进栈出栈，入后退栈。

### 3.检查拼写错误，用什么数据结构实现？

哈希表，不解释。

### 4.完全二叉树，满二叉树，堆的区别

完全二叉树是一棵树没有光秃秃的树枝，树叶长满了。满二叉树是除了最后一层，其他的树叶都长满了。堆是完全二叉树，且满足每一个节点都大于子节点的值，或小于，即大顶堆和小顶堆的概念。

### 5.第k大，即排行榜问题

可以用堆，链表的LRU算法感觉也很方便。

### 6.有向图

微信的好友关系，知乎的关注关系。

## III.哈希算法

这里仅介绍下如何解决冲突，哈希算法的概念不多赘述：

### 1.开放地址法

我们可以对哈希值取mod，或者以其他规则，挨个在内存中探测，若发现某个地址为空，则把数据存入。

### 2.多次哈希

换一种哈希算法，不可能每次都一样的值，但这样会有效率问题。

### 3.拉链法

相同哈希值的拉链表，挨个查找。

### 4.溢出区

将哈希表分为公共和溢出区域,把冲突的哈希值放在另一个地方。

# 四、数据库

## I.表

### 1.SQL语句组成部分

数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index等

数据操纵：Select ,insert,update,delete,

数据控制：grant,revoke

数据查询：select

### 2.MySQL的锁

- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

### 3.索引

索引就像是目录，为了能增加我们的查询速度而被设计了出来。

#### B+树

B+树索引能轻易存储上百万的数据，且只需要查询三次索引，非叶子节点不存储数据，但存储指向数据的位置。

真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

且B+树有数据块，能够轻易进行范围查找
#### 哈希索引

单次查询极快，但不适合做范围查询。

#### 使用索引的技巧

- 最左前缀原则：如果name是索引，email不是，则查询得先查name再匹配email。

- 选择区分度高，可能会被命中的列作为索引。

- B+树用自增索引很适合，因为增删改查不会大幅度改变B+树的结构。

- 索引值不能参与计算，否则开销极大



## II.引擎

### 1.Myisam

不支持事务，但是每次查询都是原子的；

支持表级锁，即每次操作是对整个表加锁；

存储表的总行数；

一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；

采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。

### 2.Innodb

支持ACID的事务，支持事务的四种隔离级别；

支持行级锁及外键约束：因此可以支持写并发；

不存储总行数；

一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；

主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。

## III.事务与回滚

### 1.事务的隔离级别

#### 意外情况

脏读：一个事务读了另一个事务尚未提交的修改数据

非重复读：同一个事务，在两个时刻读取某一行的结果不同。

幻读：同一个事务中，返回的结果集被改动。

#### 隔离级别

read uncommitted：读未提交，三种故障都会发生。

read commited：读已提交，除了脏读都有可能发生，也是oracle数据库的默认隔离级别。

REPEATABLE READ:可重复读，MySQL的默认事务隔离级别，只会允许幻读。通过next-key lock锁定一定范围的数据，阻止他人插入。

SERIALIZABLE：串行，效率最低，但不会有任何意外情况。

# 五、设计模式

# 六、Linux

# 七、容器云

# 八、Redis

# 九、操作系统