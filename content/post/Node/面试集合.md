---
title: "Node.js后端面试整理"
date: 2022-03-07T11:06:57+08:00
draft: true
---

# 一、Node.js语言部分

## I.语言基础

### 1.闭包的原理

函数就是一个闭包，js的特点是可以在函数内部创建另一个函数。js可以在函数内用外部的变量，所以自然而然产生的闭包概念。

```js
function foo(){
  var local = 1
  function bar(){
    local++
    return local
  }
  return bar
}

var func = foo()
func()
```

在内部的那个函数可以引用外部的变量，但同时这个变量也无法被销毁，有消耗内存的风险。


#### 块级作用域 

{}也是划分作用域的概念，和闭包略有不同。

### 2.Js的内置对象

Object、Array、Boolean、Number、String、Buffer等等。

### 3.Nodejs gc



#### 引用计数法

假设有一个对象A，任何对象对A进行引用，那么对象A的引用计数器+1，当引用失效时，对象A的引用计数器-1，当对象A的引用计数器为0时，就说明对象A没用被引用，那么就可以进行回收。

##### 优点：
- 实时性高 不需要等内存不足再回首。

- 垃圾回收的时候不需要挂起应用。

- 区域更新对象，不需要扫描全部对象

##### 缺点：
- 每次对象被引用都要更新

- 浪费cpu资源，因为内存足够的时候还在统计

- 无法解决循环引用

比如两个对象互相引用 都赋值成null，那就永远回收不了了。

#### 标记清除法

标记清除法是把gc分为两个阶段，标记和清除。

- 标记：从根节点开始标记引用的对象

- 清除：没被标记的就是垃圾对象 可以清除。

结构有点像多叉树。

从根节点开始遍历，找到所有可达的对象，其他的都是可以清除的。

##### 优点

解决了循环引用的问题

##### 缺点

标记和清除都需要遍历所有对象，gc的时候需要暂停程序。对交互性高的程序体验很差。

内存碎片多，被清理的对象在内存的各个角落。

#### 标记压缩算法

标记压缩算法是在标记清除法的基础上进行了优化，标记阶段是一样的，在清理阶段不是直接清理标记对象，而是将存活对象压缩到内存的一端，然后清理边界以外的垃圾，从而解决碎片化问题。


##### 优缺点

解决了内存碎片化的问题，但是多了压缩的一步，对象移动内存位置的步骤，对效率有影响。

### 4. 原型

在js中，对象都有__proto__属性，一般这个是被称为隐式的原型，该隐式原型指向构造该对象的构造函数的原型。

函数比较特殊，它除了和其他对象一样有__proto__属性，还有自己特有的属性----prototype，这个属性是一个指针，指向一个包含所有实例共享的属性和方法的对象，称之为原型对象。原型对象也有一个constructor属性，该属性指回该函数。



## II.libuv原理

libuv底层是用了生产者-消费者的模型，libuv在整个生命周期中，每一次循环都执行每个阶段（phase）维护的任务队列。逐个执行节点里的回调，在回调中，不断生产新的任务，从而不断驱动libuv。

### Nodejs的事件循环原理

事件循环底层使用libuv。
#### Nodejs的特点

单线程，它不会为每个请求分配一个线程，而是用主线程处理所有请求，对输入输出进行异步处理，避开了创建销毁线程，和线程切换的开销和复杂性。

#### 核心原理

Node.js 在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。

当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 I/O 任务，就从 线程池 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。

当线程中的 I/O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 事件循环 (Event Loop)。

无论是 Linux 平台还是 Windows 平台，Node.js 内部都是通过 线程池 来完成异步 I/O 操作的，而 LIBUV 针对不同平台的差异性实现了统一调用。因此，Node.js 的单线程仅仅是指 JavaScript 运行在单线程中，而并非 Node.js 是单线程。

在事件队列中，如果前面的 CPU 计算任务没有完成，后面的任务就会被阻塞，出现响应缓慢的情况，当 Node.js 被CPU 密集型任务占用，导致其他任务被阻塞时，却还有 CPU 内核处于闲置状态，造成资源浪费。

#### 使用要点

尽量不在服务器中使用需要同步等待的CPU密集型任务，如fs的同步读文件，因为这会阻塞事件队列的轮询。

**每个 CPU 密集任务只在它被调度到的时候才会得到执行。**

Node.js 有两种类型的线程：一个事件循环线程和 k 个工作线程。 事件循环负责 JavaScript 回调和非阻塞 I/O，工作线程执行与 C++ 代码对应的、完成异步请求的任务，包括阻塞 I/O 和 CPU 密集型工作。 

这两种类型的线程一次都只能处理一个活动。 如果任意一个回调或任务需要很长时间，则运行它的线程将被 阻塞。 如果你的应用程序发起阻塞的回调或任务，在好的情况下这可能只会导致吞吐量下降（客户端/秒），而在最坏情况下可能会导致完全拒绝服务。

## III.v8

v8解决的问题是快速解析和执行JavaScript脚本。

### 1.内存限制

32位是0.7gb，64位是1.4gb

### 2.和Nodejs的关系

v8把js代码翻译成机器码，直接运行。

### 3.内存结构

内存区主要能够分为如下几类：栈区、堆区、常量区、函数定义区、函数缓存区。

#### 堆区

JavaScript的变量名是用来保存内存中某块内存区的地址的，而栈区就是用来保存变量名和内存地址的键值对的。

```js
let a = {}
```

对于该语句，V8会在堆区中开辟一块内存，而后在栈区添加一个键值对，键名是咱们声明的变量名a，键值是堆区中开辟出的内存的地址。

在堆区中存在一个特殊的预置对象null，它在堆区中有固定的内存地址，而且是惟一的。也就是说全部被赋值为null的变量指向的都是这同一块内存地址（所以被赋值为null的变量也是有内存地址的）。

#### 常量区


- 全部的值都是不可变的
- 全部相同的常量值在常量区都是唯一的。

#### 函数定义区

```js
//函数声明
function f(){
  ...
}
//函数引用
var f = function(){
 ...
}
```

其实没什么卵用的知识。

```js
//能够正常调用，由于引擎会提早扫描代码，将该函数存储到函数定义区
f();
function f(){}

//报错，由于虽然g也进行了变量提高，但此时g的值是undefined，不能调用
g();
var g = function(){}
```
#### 函数缓存区

所谓函数缓存区，就是函数运行所用的内存区。当V8引擎须要执行一个函数时，它就会在函数缓存区开辟一块内存，保存该函数运行所须要存储的状态和变量。

一般情况都会回收内存，用了闭包就有可能不回收（上面有提到）

#### 理解 == 和 ===

```js
var a = 1;
var b = 1;
a === b;   //值为true，同一个常量在常量区只会生成一个，所以二者获得地址是同样的

var a = {};
var b = {};
a === b;    //值为false，引擎会分别为a和b开辟内存，所以二者的地址并不相同

null === null;  //值为true，由于堆区只有一个null
[] === [];  //值为false，原理与{}相同
```

在比较字符串的时候，数字会先转成字符串，然后去比较地址。


### 4.V8的垃圾回收机制

V8的垃圾回收机制采用的是标记清除法，这也是如今JavaScript引擎通用的一种回收机制。

新生代空间小一点，老生代空间大一点。

#### 新生代

新生代区域一分为二，每个16M，一个使用，一个空闲。

开始垃圾回收的时候，会检查FROM区域中的存活对象，如果还活着，拷贝到TO空间，所有存活对象拷贝完后，清空(释放)FROM区域
然后FROM和To区域互换。

新生代的空间小，存活对象少。

当一个对象经理多次的垃圾回收依然存活的时候，生存周期比较差的对象会被移动到老生代，这个移动过程被称为晋升或升级。

- 经历过5次以上的回收还存在

- TO的空间使用占比超过25%，或者超大对象

#### 老生代

老生代垃圾回收策略分为两种：

##### mark-sweep 标记清除

标记活着的对象，虽然清楚在标记阶段没有标记的对象，只清理死亡对象

会出现的问题：清除后内存不连续，碎片内存无法分配

##### mark-compact 标记整理

标记死亡后会对对象进行整理，活着的左移，移动完成后清理掉边界外的内存(死亡的对象)

老生代空间大，大部分都是活着的对象，GC耗时比较长

**GC的时候程序无法进行响应**

# 二、计算机网络

### I.网络架构

七层网络模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。

### II.三次握手

#### 粗略的目的

- 第一次客户端给服务器发送，服务器能确认客户端的发送、服务器的接收能力。

- 第二次服务器给客户端发送，客户端能确认服务器的发送、客户端的接收能力。同时根据第一次握手，能知道自己的发送、服务器的接收都正常。

**为什么需要三次握手**

- 因为服务器不知道自己的发送，客户端的接收是否正常，所以需要第三次握手，得到客户端的应答才能做最后的确认。

#### SYN和ACK

SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。

#### 位码

位码即tcp标志位，有6种标示：SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码)

### III.四次挥手


- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送

- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号

- 服务器-关闭与客户端的连接，发送一个FIN给客户端

- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1

### IV.各种协议

#### 1.TCP,UDP 协议的区别

UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等。

TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。

#### 2.TCP 协议如何保证可靠传输

简单来说，数据会分包、TCP有检验和：判断数据有缺失会直接丢掉，而且不确认这次收到了、流量控制、拥塞处理、ARQ协议。

#### 3.DNS

域名系统，能够获取域名对应的ip地址。

### V.http协议

#### 1.当输入www.google.com时，页面发生了哪些事情

1. 域名解析检查顺序为：浏览器自身DNS缓存---》OS自身的DNS缓存--》读取host文件--》本地域名服务器--》权限域名服务器--》根域名服务器。如果有且没有过期，则结束本次域名解析。域名解析成功之后，进行后续操作。

2. 三次握手

3. 建立连接，发起http请求。

4. 服务器响应，浏览器得到内容。

5. 浏览器解析html代码，并且请求其中的资源

6. 浏览器对页面渲染，呈现给用户。

#### 2.什么是Http协议无状态协议？怎么解决Http协议无状态协议？

http是无状态的，也就是后续处理无法处理之前的信息。

处理办法有Cookie，Section会话保存，甚至可以用数据库和缓存处理。

#### 3.http协议组成

**请求报文包含三部分：**

- 请求行：包含请求方法、URI、HTTP版本信息

- 请求首部字段

- 请求内容实体
  
**响应报文包含三部分：**

- 状态行：包含HTTP版本、状态码、状态码的原因短语

- 响应首部字段

- 响应内容实体

**空行**

最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。

**请求正文**

请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。


**返回值**


在接收和解释请求消息后，服务器返回一个HTTP响应消息。

HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文



##### 请求行

请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。

GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，

POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。

个人不推荐用GET，全部用POST比较方便。

##### 请求头部

请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：

- User-Agent：产生请求的浏览器类型。

 
- Accept：客户端可识别的内容类型列表。

 
- Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。




#### 4.状态码

- 1xx：指示信息--表示请求已接收，继续处理

- 2xx：成功--表示请求已被成功接收、理解、接受

- 3xx：重定向--要完成请求必须进行更进一步的操作

- 4xx：客户端错误--请求有语法错误或请求无法实现

- 5xx：服务器端错误--服务器未能实现合法的请求


#### 5.http的版本 1.0与1.1

在http1.0中，当建立连接后，客户端发送一个请求，服务器端返回一个信息后就关闭连接，当浏览器下次请求的时候又要建立连接，显然这种不断建立连接的方式，会造成很多问题。

在http1.1中，引入了持续连接的概念，通过这种连接，浏览器可以建立一个连接之后，发送请求并得到返回信息，然后继续发送请求再次等到返回信息，也就是说客户端可以连续发送多个请求，而不用等待每一个响应的到来。



#### 6.GET和POST的区别

GET重点是请求数据，POST的重点是提交数据。GET传输数据以URL的方式，POST通过http的post机制，把数据封装在了请求实体中，所以是不可见的，安全性也更高一点。

GET只支持ASCII字符，有可能出现乱码，POST不会。

### VI.https和http

HTTPS协议 = HTTP协议 + SSL/TLS协议，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输，由此可以看出HTTPS是由HTTP和SSL/TLS一起合作完成的。

#### 传输的过程



# 三、数据结构和算法

# 四、数据库

# 五、设计模式

# 六、Linux

# 七、容器云

# 八、Redis

# 九、操作系统